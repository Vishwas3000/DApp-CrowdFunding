{
  "language": "Solidity",
  "sources": {
    "contracts/Campaign.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport \"./Stake.sol\";\n\nerror Campaign__SendMinFund();\nerror Campaign__NotOwner();\nerror Campaign__NotEnoughToWithdraw();\nerror Campaign__RequestIsUnderProcess();\nerror Campaign__RequestRejected();\nerror Campaign__NotAnEligiableContributer();\n\ncontract Campaign is Stake {\n    mapping(address => uint256) public s_contributerFund;\n    uint256 private immutable i_campaignGoal;\n    uint256 private immutable i_minContribution;\n    uint256 private s_TotalFunded;\n    address private s_owner;\n    Request[] private s_requests;\n    address[] private s_contributers;\n\n    event FundWithdrawed(uint256 amountWithdrawed);\n    event OwnershipTransfered(address from, address to);\n    event FundTransfered(address from, uint256 fundedAmount);\n    event RequestApplied(uint256 requestIndex);\n    event RequestResult(uint256 requestIndex, bool approved);\n\n    constructor(uint256 campaignGoal, uint256 minContribution) {\n        i_campaignGoal = campaignGoal;\n        i_minContribution = minContribution;\n        s_owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != s_owner) {\n            revert Campaign__NotOwner();\n        }\n        _;\n    }\n\n    modifier permissionIssued(uint256 requestIndex) {\n        if (\n            getPermissionStatus(s_requests[requestIndex]) ==\n            CampaignLib.permission.PROCESSING\n        ) {\n            revert Campaign__RequestIsUnderProcess();\n        }\n        if (\n            getPermissionStatus(s_requests[requestIndex]) ==\n            CampaignLib.permission.REJECTED\n        ) {\n            revert Campaign__RequestRejected();\n        }\n        _;\n    }\n\n    modifier onlyEligiableContributers(\n        uint256 minContribution,\n        address contributer\n    ) {\n        if (s_contributerFund[contributer] < minContribution) {\n            revert Campaign__NotAnEligiableContributer();\n        }\n        _;\n    }\n\n    function contribute() public payable {\n        if (msg.value < i_minContribution) {\n            revert Campaign__SendMinFund();\n        }\n        (bool send, ) = address(this).call{value: msg.value}(\"\");\n\n        emit FundTransfered(msg.sender, msg.value);\n\n        s_contributerFund[msg.sender] += msg.value;\n        s_TotalFunded += msg.value;\n        s_contributers.push(msg.sender);\n    }\n\n    function withdraw(\n        uint256 requestIndex\n    ) public payable onlyOwner permissionIssued(requestIndex) {\n        uint256 amount = getRequestedAmount(s_requests[requestIndex]);\n        if (address(this).balance < amount) {\n            revert Campaign__NotEnoughToWithdraw();\n        }\n        (bool sent, ) = s_owner.call{value: amount}(\"\");\n        setRecieved(s_requests[requestIndex]);\n        emit FundWithdrawed(amount);\n    }\n\n    function makeRequest(\n        uint256 _durationOfRequest,\n        uint256 _withdrawAmount,\n        uint256 _minContributionToVote\n    ) public onlyOwner {\n        // Stake happens here\n\n        Request storage request = s_requests.push();\n        request.minContributionToVote = _minContributionToVote;\n        request.durationOfRequest = _durationOfRequest;\n        request.requestedAmount = _withdrawAmount;\n        request.requestedTime = block.timestamp;\n        request.totalAcceptVote = 0;\n        request.totalRejectVote = 0;\n        request.amountRecieved = false;\n        request.currentStatus = CampaignLib.permission.PROCESSING;\n        emit RequestApplied(s_requests.length);\n    }\n\n    function stakeInRequest(uint256 requestId, CampaignLib.vote myVote) public {\n        stake(s_requests[requestId], myVote);\n    }\n\n    function executeResult(uint256 requestIndex) public {\n        result(s_requests[requestIndex]);\n\n        emit RequestResult(\n            requestIndex,\n            getPermissionStatus(s_requests[requestIndex]) ==\n                CampaignLib.permission.ACCEPTED\n        );\n    }\n\n    // Getter and setter functions\n\n    function getContributors() public view returns (address[] memory) {\n        return s_contributers;\n    }\n\n    function getTotalFund() public view returns (uint256) {\n        return s_TotalFunded;\n    }\n\n    function getFundByAddress(\n        address contributer\n    ) public view returns (uint256) {\n        return s_contributerFund[contributer];\n    }\n\n    function getOwnerAddress() public view returns (address) {\n        return s_owner;\n    }\n\n    function transferOwnerShip(address to) public onlyOwner {\n        s_owner = to;\n        emit OwnershipTransfered(msg.sender, to);\n    }\n\n    function getCurrentFundInContract() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function getContributorsFundAmount(\n        address contributerAddress\n    ) public view returns (uint256) {\n        return s_contributerFund[contributerAddress];\n    }\n\n    function getCampaignGoal() public view returns (uint256) {\n        return i_campaignGoal;\n    }\n}\n"
    },
    "contracts/CrowdFunding.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"./Campaign.sol\";\r\n\r\ncontract CrowdFunding {\r\n    mapping(address => Campaign[]) private s_campaigns;\r\n    address[] private s_campaignCreaters;\r\n\r\n    event CampaignCreated(address campaignCreator, uint256 campaginId);\r\n\r\n    function createCampaign(\r\n        uint256 _campaignGoal,\r\n        uint256 _minContribution\r\n    ) public {\r\n        Campaign campaign = new Campaign(_campaignGoal, _minContribution);\r\n        s_campaigns[msg.sender].push(campaign);\r\n        s_campaignCreaters.push(msg.sender);\r\n\r\n        emit CampaignCreated(msg.sender, s_campaigns[msg.sender].length);\r\n    }\r\n\r\n    function getCampaign(\r\n        address owner,\r\n        uint256 campaignId\r\n    ) public view returns (address) {\r\n        return address(s_campaigns[owner][campaignId]);\r\n    }\r\n\r\n    function getAllCampaignOfOwner(\r\n        address owner\r\n    ) public view returns (address[] memory) {\r\n        uint256 totalCampaign = s_campaigns[owner].length;\r\n        address[] memory campaigns = new address[](totalCampaign);\r\n        for (uint i = 0; i < totalCampaign; i++) {\r\n            campaigns[i] = address(s_campaigns[owner][i]);\r\n        }\r\n        return campaigns;\r\n    }\r\n\r\n    // Implement a function to get s_campagins\r\n    // function getAllCampaign() public view returns () {\r\n\r\n    // }\r\n}\r\n"
    },
    "contracts/Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary CampaignLib {\r\n    enum permission {\r\n        PROCESSING,\r\n        ACCEPTED,\r\n        REJECTED\r\n    }\r\n\r\n    enum vote {\r\n        ACCEPT,\r\n        REJECT\r\n    }\r\n}\r\n"
    },
    "contracts/Stake.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"./Library.sol\";\r\n\r\n// TO DO\r\n//\r\n// Start the stake event\r\n// contributers can vote\r\n// End the event\r\n// Send the result and withdraw if needed\r\n\r\nerror Stake__DeadlineNotReached();\r\nerror Stake__DeadLineReached();\r\n\r\ncontract Stake {\r\n    struct Request {\r\n        mapping(address => bool) contributersVoted;\r\n        uint256 minContributionToVote;\r\n        uint256 durationOfRequest;\r\n        uint256 requestedAmount;\r\n        uint256 requestedTime;\r\n        // Voting variables\r\n        uint256 totalAcceptVote;\r\n        uint256 totalRejectVote;\r\n        // status\r\n        CampaignLib.permission currentStatus;\r\n        bool amountRecieved;\r\n    }\r\n\r\n    modifier deadlineReached(Request storage request, bool requireReached) {\r\n        uint256 timeRemaining = timeLeft(request);\r\n        if (requireReached) {\r\n            if (timeRemaining > 0) {\r\n                revert Stake__DeadlineNotReached();\r\n            }\r\n            // require(timeRemaining == 0, \"Deadline has not reached\");\r\n        } else {\r\n            if (timeRemaining == 0) {\r\n                revert Stake__DeadLineReached();\r\n            }\r\n            // require(timeRemaining > 0, \"Deadline is already reached\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    // Add a modifier if all the contributers voted\r\n\r\n    function stake(\r\n        Request storage request,\r\n        CampaignLib.vote myVote\r\n    ) internal deadlineReached(request, false) {\r\n        if (myVote == CampaignLib.vote.ACCEPT) {\r\n            request.totalAcceptVote += 1;\r\n        } else {\r\n            request.totalRejectVote += 1;\r\n        }\r\n    }\r\n\r\n    // Make a function that gets call for chainlink\r\n\r\n    function result(\r\n        Request storage request\r\n    ) internal deadlineReached(request, true) {\r\n        if (request.totalAcceptVote > request.totalRejectVote) {\r\n            request.currentStatus = CampaignLib.permission.ACCEPTED;\r\n        } else {\r\n            request.currentStatus = CampaignLib.permission.REJECTED;\r\n        }\r\n    }\r\n\r\n    function timeLeft(\r\n        Request storage request\r\n    ) internal view returns (uint256 timeleft) {\r\n        uint256 deadline = request.requestedTime + request.durationOfRequest;\r\n        if (block.timestamp >= deadline) {\r\n            return 0;\r\n        } else {\r\n            return deadline - block.timestamp;\r\n        }\r\n    }\r\n\r\n    function getCurrentStatus(\r\n        Request storage request\r\n    ) internal view returns (CampaignLib.permission) {\r\n        return request.currentStatus;\r\n    }\r\n\r\n    function getRequestedAmount(\r\n        Request storage request\r\n    ) internal view returns (uint256) {\r\n        return request.requestedAmount;\r\n    }\r\n\r\n    function setRecieved(Request storage request) internal {\r\n        request.amountRecieved = true;\r\n    }\r\n\r\n    function getMinimumContribution(\r\n        Request storage request\r\n    ) internal view returns (uint256) {\r\n        return request.minContributionToVote;\r\n    }\r\n\r\n    function getPermissionStatus(\r\n        Request storage request\r\n    ) internal view returns (CampaignLib.permission) {\r\n        return request.currentStatus;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}