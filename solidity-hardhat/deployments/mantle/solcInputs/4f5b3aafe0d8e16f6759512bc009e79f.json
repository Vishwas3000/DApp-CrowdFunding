{
  "language": "Solidity",
  "sources": {
    "contracts/CrowdFunding.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport \"./Stake.sol\";\nimport \"./Library.sol\";\n\nerror Campagin__SendMinFund();\nerror Campagin__NotOwner();\nerror Campagin__NotEnoughToWithdraw();\nerror Campagin__RequestIsUnderProcess();\nerror Campagin__RequestRejected();\nerror CrowdFunding__RequestRejected();\n\ncontract CrowdFunding {\n    mapping(address => uint256) public s_contributerFund;\n    uint256 private immutable i_campaginGoal;\n    uint256 private immutable i_minContribution;\n    uint256 private s_TotalFunded;\n    address private s_owner;\n    Stake[] private s_requestes;\n    address[] private s_contributers;\n\n    event FundWithdrawed(uint256 amountWithdrawed);\n    event OwnershipTransfered(address from, address to);\n    event FundTransfered(address from, uint256 fundedAmount);\n    event RequestApplied(Stake request);\n\n    constructor(uint256 campaginGoal, uint256 minContribution) {\n        i_campaginGoal = campaginGoal;\n        i_minContribution = minContribution;\n        s_owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != s_owner) {\n            revert Campagin__NotOwner();\n        }\n        _;\n    }\n\n    modifier permissionIssued(uint256 requestIndex) {\n        if (\n            s_requestes[requestIndex].getPermission() ==\n            withdrawLib.withdrawPermission.PROCESSING\n        ) {\n            revert Campagin__RequestIsUnderProcess();\n        }\n        if (\n            s_requestes[requestIndex].getPermission() ==\n            withdrawLib.withdrawPermission.REJECTED\n        ) {\n            revert Campagin__RequestRejected();\n        }\n        _;\n    }\n\n    function contribute() public payable {\n        if (msg.value < i_minContribution) {\n            revert Campagin__SendMinFund();\n        }\n        (bool send, ) = address(this).call{value: msg.value}(\"\");\n\n        emit FundTransfered(msg.sender, msg.value);\n\n        s_contributerFund[msg.sender] += msg.value;\n        s_TotalFunded += msg.value;\n        s_contributers.push(msg.sender);\n    }\n\n    // function withdraw() public payable onlyOwner {\n    //     if (address(this).balance <= 0) {\n    //         revert Campagin__NotEnoughToWithdraw();\n    //     }\n    //     uint256 withdrawAmount = address(this).balance;\n    //     (bool sent, ) = s_owner.call{value: address(this).balance}(\"\");\n    //     emit FundWithdrawed(withdrawAmount);\n    // }\n\n    function withdraw(\n        uint256 requestIndex\n    ) public payable onlyOwner permissionIssued(requestIndex) {\n        uint256 amount = s_requestes[requestIndex].getRequestedAmount();\n        if (address(this).balance < amount) {\n            revert Campagin__NotEnoughToWithdraw();\n        }\n        (bool sent, ) = s_owner.call{value: amount}(\"\");\n        s_requestes[requestIndex].setRecieved();\n        emit FundWithdrawed(amount);\n    }\n\n    function makeRequest(\n        uint256 durationOfRequest,\n        uint256 withdrawAmount,\n        uint256 minContributionToVote\n    ) public {\n        // Stake happens here\n\n        Stake request = new Stake(\n            address(this),\n            durationOfRequest,\n            withdrawAmount,\n            minContributionToVote\n        );\n        s_requestes.push(request);\n        emit RequestApplied(request);\n    }\n\n    function getContributors() public view returns (address[] memory) {\n        return s_contributers;\n    }\n\n    function getTotalFund() public view returns (uint256) {\n        return s_TotalFunded;\n    }\n\n    function getFundByAddress(\n        address contributer\n    ) public view returns (uint256) {\n        return s_contributerFund[contributer];\n    }\n\n    function getOwnerAddress() public view returns (address) {\n        return s_owner;\n    }\n\n    function transferOwnerShip(address to) public onlyOwner {\n        s_owner = to;\n        emit OwnershipTransfered(msg.sender, to);\n    }\n\n    function getCurrentFundInContract() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function getContributorsFundAmount(\n        address contributerAddress\n    ) public view returns (uint256) {\n        return s_contributerFund[contributerAddress];\n    }\n}\n"
    },
    "contracts/Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary withdrawLib {\r\n    enum withdrawPermission {\r\n        PROCESSING,\r\n        ACCEPTED,\r\n        REJECTED\r\n    }\r\n}\r\n"
    },
    "contracts/Stake.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"./Library.sol\";\r\n\r\n// TO DO\r\n//\r\n// Start the stake event\r\n// contributers can vote\r\n// End the event\r\n// Send the result and withdraw if needed\r\n\r\ncontract Stake {\r\n    enum vote {\r\n        ACCEPT,\r\n        REJECT,\r\n        NEUTRAL\r\n    }\r\n\r\n    mapping(address => bool) private s_contributersVoted;\r\n    address private immutable i_campaginAddress;\r\n    uint256 private immutable i_minContributionToVote;\r\n    uint256 private s_durationOfRequest;\r\n    uint256 private s_requestedAmount;\r\n    uint256 private s_requestedTime;\r\n\r\n    uint256 private s_totalNeutralVote;\r\n    uint256 private s_totalAcceptVote;\r\n    uint256 private s_totalRejectVote;\r\n\r\n    withdrawLib.withdrawPermission private s_permission;\r\n\r\n    bool private s_recieved;\r\n\r\n    constructor(\r\n        address campaginAddress,\r\n        uint256 duration,\r\n        uint256 requestedAmount,\r\n        uint256 minContributionToVote\r\n    ) {\r\n        i_campaginAddress = campaginAddress;\r\n        i_minContributionToVote = minContributionToVote;\r\n        s_durationOfRequest = duration;\r\n        s_permission = withdrawLib.withdrawPermission.PROCESSING;\r\n        s_requestedAmount = requestedAmount;\r\n        s_requestedTime = block.timestamp;\r\n        s_recieved = false;\r\n    }\r\n\r\n    modifier deadlineReached(bool requireReached) {\r\n        uint256 timeRemaining = timeLeft();\r\n        if (requireReached) {\r\n            require(timeRemaining == 0, \"Deadline is not reached yet\");\r\n        } else {\r\n            require(timeRemaining > 0, \"Deadline is already reached\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    // Add a modifier if all the contributers voted\r\n\r\n    function stake(vote myVote) public deadlineReached(false) {\r\n        if (myVote == vote.ACCEPT) {\r\n            s_totalAcceptVote += 1;\r\n        } else if (myVote == vote.NEUTRAL) {\r\n            s_totalNeutralVote += 1;\r\n        } else {\r\n            s_totalRejectVote;\r\n        }\r\n    }\r\n\r\n    // Make a function that gets call for chainlink\r\n\r\n    function result() public deadlineReached(true) {\r\n        if (s_totalAcceptVote > s_totalRejectVote) {\r\n            s_permission = withdrawLib.withdrawPermission.ACCEPTED;\r\n        } else {\r\n            s_permission = withdrawLib.withdrawPermission.REJECTED;\r\n        }\r\n    }\r\n\r\n    function timeLeft() public view returns (uint256 timeleft) {\r\n        uint256 deadline = s_requestedTime + s_durationOfRequest;\r\n        if (block.timestamp >= deadline) {\r\n            return 0;\r\n        } else {\r\n            return deadline - block.timestamp;\r\n        }\r\n    }\r\n\r\n    function getPermission()\r\n        public\r\n        view\r\n        returns (withdrawLib.withdrawPermission)\r\n    {\r\n        return s_permission;\r\n    }\r\n\r\n    function getRequestedAmount() public view returns (uint256) {\r\n        return s_requestedAmount;\r\n    }\r\n\r\n    function setRecieved() public {\r\n        s_recieved = true;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}