{
  "language": "Solidity",
  "sources": {
    "contracts/Campaign.sol": {
      "content": "// // SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"./Stake.sol\";\r\n\r\nerror Campaign__SendMinFund();\r\nerror Campaign__NotOwner();\r\nerror Campaign__NotEnoughToWithdraw();\r\nerror Campaign__RequestIsUnderProcess();\r\nerror Campaign__RequestRejected();\r\nerror Campaign__NotAnEligiableContributer();\r\nerror Campaign__ContributionTransactionFailed();\r\nerror Campaign__WithdrawTransactionFailed();\r\nerror Campaign__NoEnoughAmount();\r\nerror Campaign__NotAContributer();\r\n\r\ncontract Campaign is Stake {\r\n    mapping(address => uint256) public s_contributerFund;\r\n    uint256 private immutable i_campaignGoal;\r\n    uint256 private immutable i_minContribution;\r\n    uint256 private s_TotalFunded;\r\n    address private s_owner;\r\n    Request[] private s_requests;\r\n    address[] private s_contributers;\r\n\r\n    event FundWithdrawed(uint256 amountWithdrawed);\r\n    event OwnershipTransfered(address from, address to);\r\n    event FundTransfered(address from, uint256 fundedAmount);\r\n    event RequestApplied(uint256 requestIndex);\r\n    event RequestResult(uint256 requestIndex, bool approved);\r\n\r\n    constructor(uint256 campaignGoal, uint256 minContribution) {\r\n        i_campaignGoal = campaignGoal;\r\n        i_minContribution = minContribution;\r\n        s_owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != s_owner) {\r\n            revert Campaign__NotOwner();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyContributers() {\r\n        if (s_contributerFund[msg.sender] == 0) {\r\n            revert Campaign__NotAContributer();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier permissionIssued(uint256 requestIndex) {\r\n        executeResult(requestIndex);\r\n        if (\r\n            getPermissionStatus(s_requests[requestIndex]) ==\r\n            CampaignLib.permission.PROCESSING\r\n        ) {\r\n            revert Campaign__RequestIsUnderProcess();\r\n        }\r\n        if (\r\n            getPermissionStatus(s_requests[requestIndex]) ==\r\n            CampaignLib.permission.REJECTED\r\n        ) {\r\n            revert Campaign__RequestRejected();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function contribute() public payable {\r\n        if (msg.value < i_minContribution) {\r\n            revert Campaign__SendMinFund();\r\n        }\r\n        (bool sent, ) = address(this).call{value: msg.value}(\"\");\r\n\r\n        if (!sent) {\r\n            revert Campaign__ContributionTransactionFailed();\r\n        }\r\n\r\n        emit FundTransfered(msg.sender, msg.value);\r\n\r\n        s_contributerFund[msg.sender] += msg.value;\r\n        s_TotalFunded += msg.value;\r\n        s_contributers.push(msg.sender);\r\n    }\r\n\r\n    function withdraw(\r\n        uint256 requestIndex\r\n    ) public payable onlyOwner permissionIssued(requestIndex) {\r\n        uint256 amount = getRequestedAmount(s_requests[requestIndex]);\r\n        if (address(this).balance < amount) {\r\n            revert Campaign__NotEnoughToWithdraw();\r\n        }\r\n        (bool sent, ) = s_owner.call{value: amount}(\"\");\r\n\r\n        if (!sent) {\r\n            revert Campaign__WithdrawTransactionFailed();\r\n        }\r\n\r\n        setRecieved(s_requests[requestIndex]);\r\n        emit FundWithdrawed(amount);\r\n    }\r\n\r\n    function makeRequest(\r\n        uint256 _durationOfRequest,\r\n        uint256 _withdrawAmount\r\n    ) public onlyOwner {\r\n        // Stake happens here\r\n\r\n        Request storage request = s_requests.push();\r\n        request.durationOfRequest = _durationOfRequest;\r\n        request.requestedAmount = _withdrawAmount;\r\n        request.requestedTime = block.timestamp;\r\n        request.totalAcceptVote = 0;\r\n        request.totalRejectVote = 0;\r\n        request.amountRecieved = false;\r\n        request.campaignAddress = address(this);\r\n        request.currentStatus = CampaignLib.permission.PROCESSING;\r\n        emit RequestApplied(s_requests.length - 1);\r\n    }\r\n\r\n    function stakeInRequest(uint256 requestId, CampaignLib.vote myVote) public {\r\n        uint256 weightage = calcualtePercent(\r\n            s_contributerFund[msg.sender],\r\n            10000,\r\n            s_TotalFunded\r\n        );\r\n        stake(s_requests[requestId], myVote, msg.sender, weightage);\r\n    }\r\n\r\n    function executeResult(uint256 requestIndex) public {\r\n        result(s_requests[requestIndex]);\r\n\r\n        emit RequestResult(\r\n            requestIndex,\r\n            getPermissionStatus(s_requests[requestIndex]) ==\r\n                CampaignLib.permission.ACCEPTED\r\n        );\r\n    }\r\n\r\n    // Getter and setter functions\r\n\r\n    function getContributors() public view returns (address[] memory) {\r\n        return s_contributers;\r\n    }\r\n\r\n    function getTotalFund() public view returns (uint256) {\r\n        return s_TotalFunded;\r\n    }\r\n\r\n    function getFundByAddress(\r\n        address contributer\r\n    ) public view returns (uint256) {\r\n        return s_contributerFund[contributer];\r\n    }\r\n\r\n    function getOwnerAddress() public view returns (address) {\r\n        return s_owner;\r\n    }\r\n\r\n    function transferOwnerShip(address to) public onlyOwner {\r\n        s_owner = to;\r\n        emit OwnershipTransfered(msg.sender, to);\r\n    }\r\n\r\n    function getCurrentFundInContract() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getContributorsFundAmount(\r\n        address contributerAddress\r\n    ) public view returns (uint256) {\r\n        return s_contributerFund[contributerAddress];\r\n    }\r\n\r\n    function getCampaignGoal() public view returns (uint256) {\r\n        return i_campaignGoal;\r\n    }\r\n\r\n    function getTotalContributers() public view returns (uint256) {\r\n        return s_contributers.length;\r\n    }\r\n\r\n    function calcualtePercent(\r\n        uint256 amount,\r\n        uint256 bps,\r\n        uint256 totalAmount\r\n    ) internal pure returns (uint256) {\r\n        if (amount * bps < totalAmount) {\r\n            revert Campaign__NoEnoughAmount();\r\n        }\r\n        return (amount * bps) / totalAmount;\r\n    }\r\n\r\n    // uint256 durationOfRequest;\r\n    //     uint256 requestedAmount;\r\n    //     uint256 requestedTime;\r\n    //     address campaignAddress;\r\n    //     // Voting variables\r\n    //     uint256 totalAcceptVote;\r\n    //     uint256 totalRejectVote;\r\n    //     // status\r\n    //     CampaignLib.permission currentStatus;\r\n    //     bool amountRecieved;\r\n\r\n    function getRequestInfo(\r\n        uint256 requestId\r\n    ) public view returns (uint256, uint256, uint256, uint256, bool) {\r\n        return (\r\n            s_requests[requestId].requestedAmount,\r\n            s_requests[requestId].requestedTime,\r\n            s_requests[requestId].durationOfRequest,\r\n            uint256(s_requests[requestId].currentStatus),\r\n            s_requests[requestId].amountRecieved\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/CampaignLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary CampaignLib {\r\n    enum permission {\r\n        PROCESSING,\r\n        ACCEPTED,\r\n        REJECTED\r\n    }\r\n\r\n    enum vote {\r\n        ACCEPT,\r\n        REJECT\r\n    }\r\n}\r\n"
    },
    "contracts/CrowdFunding.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"./Campaign.sol\";\r\n\r\ncontract CrowdFunding {\r\n    mapping(address => Campaign[]) private s_campaigns;\r\n    address[] private s_campaignCreaters;\r\n    uint256 private s_totalCampaign;\r\n\r\n    event CampaignCreated(\r\n        address campaignCreator,\r\n        uint256 campaginId,\r\n        address campaignAddress\r\n    );\r\n\r\n    function createCampaign(\r\n        uint256 _campaignGoal,\r\n        uint256 _minContribution\r\n    ) public {\r\n        Campaign campaign = new Campaign(_campaignGoal, _minContribution);\r\n        campaign.transferOwnerShip(msg.sender);\r\n\r\n        s_campaigns[msg.sender].push(campaign);\r\n        s_campaignCreaters.push(msg.sender);\r\n\r\n        s_totalCampaign += 1;\r\n\r\n        emit CampaignCreated(\r\n            msg.sender,\r\n            s_campaigns[msg.sender].length - 1,\r\n            address(campaign)\r\n        );\r\n    }\r\n\r\n    function getCampaign(\r\n        address owner,\r\n        uint256 campaignId\r\n    ) public view returns (address) {\r\n        return address(s_campaigns[owner][campaignId]);\r\n    }\r\n\r\n    function getAllCampaignOfOwner(\r\n        address owner\r\n    ) public view returns (address[] memory) {\r\n        uint256 totalCampaign = s_campaigns[owner].length;\r\n        address[] memory campaigns = new address[](totalCampaign);\r\n        for (uint i = 0; i < totalCampaign; i++) {\r\n            campaigns[i] = address(s_campaigns[owner][i]);\r\n        }\r\n        return campaigns;\r\n    }\r\n\r\n    function getTotalCampaign() public view returns (uint256) {\r\n        return s_totalCampaign;\r\n    }\r\n\r\n    // Implement a function to get s_campagins\r\n    // function getAllCampaign() public view returns () {\r\n\r\n    // }\r\n}\r\n"
    },
    "contracts/Stake.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"./CampaignLib.sol\";\r\n\r\n// TO DO\r\n//\r\n// Start the stake event\r\n// contributers can vote\r\n// End the event\r\n// Send the result and withdraw if needed\r\n//\r\n\r\nerror Stake__DeadlineNotReached();\r\nerror Stake__DeadLineReached();\r\nerror Stake__ContributerAlreadyVoted();\r\n\r\ncontract Stake {\r\n    struct Request {\r\n        mapping(address => bool) contributersVoted;\r\n        uint256 durationOfRequest;\r\n        uint256 requestedAmount;\r\n        uint256 requestedTime;\r\n        address campaignAddress;\r\n        // Voting variables\r\n        uint256 totalAcceptVote;\r\n        uint256 totalRejectVote;\r\n        // status\r\n        CampaignLib.permission currentStatus;\r\n        bool amountRecieved;\r\n    }\r\n\r\n    modifier deadlineReached(Request storage request, bool requireReached) {\r\n        uint256 timeRemaining = timeLeft(request);\r\n        if (requireReached) {\r\n            if (timeRemaining > 0) {\r\n                revert Stake__DeadlineNotReached();\r\n            }\r\n            // require(timeRemaining == 0, \"Deadline has not reached\");\r\n        } else {\r\n            if (timeRemaining == 0) {\r\n                revert Stake__DeadLineReached();\r\n            }\r\n            // require(timeRemaining > 0, \"Deadline is already reached\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    // Add a modifier if all the contributers voted\r\n\r\n    function stake(\r\n        Request storage request,\r\n        CampaignLib.vote myVote,\r\n        address contributer,\r\n        uint256 weightage\r\n    ) internal deadlineReached(request, false) {\r\n        if (request.contributersVoted[contributer]) {\r\n            revert Stake__ContributerAlreadyVoted();\r\n        }\r\n        request.contributersVoted[contributer] = true;\r\n        if (myVote == CampaignLib.vote.ACCEPT) {\r\n            request.totalAcceptVote += weightage;\r\n        } else {\r\n            request.totalRejectVote += weightage;\r\n        }\r\n    }\r\n\r\n    // Make a function that gets call for chainlink\r\n\r\n    function result(\r\n        Request storage request\r\n    ) internal deadlineReached(request, true) {\r\n        if (request.totalAcceptVote > request.totalRejectVote) {\r\n            request.currentStatus = CampaignLib.permission.ACCEPTED;\r\n        } else {\r\n            request.currentStatus = CampaignLib.permission.REJECTED;\r\n        }\r\n    }\r\n\r\n    function timeLeft(\r\n        Request storage request\r\n    ) internal view returns (uint256 timeleft) {\r\n        uint256 deadline = request.requestedTime + request.durationOfRequest;\r\n        if (block.timestamp >= deadline) {\r\n            return 0;\r\n        } else {\r\n            return deadline - block.timestamp;\r\n        }\r\n    }\r\n\r\n    function getCurrentStatus(\r\n        Request storage request\r\n    ) internal view returns (CampaignLib.permission) {\r\n        return request.currentStatus;\r\n    }\r\n\r\n    function getRequestedAmount(\r\n        Request storage request\r\n    ) internal view returns (uint256) {\r\n        return request.requestedAmount;\r\n    }\r\n\r\n    function setRecieved(Request storage request) internal {\r\n        request.amountRecieved = true;\r\n    }\r\n\r\n    function getPermissionStatus(\r\n        Request storage request\r\n    ) internal view returns (CampaignLib.permission) {\r\n        return request.currentStatus;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}